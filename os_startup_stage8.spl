load(7,1);    //loads exception handler to memory
load(8,1);


load(23,17);  //loads interrupt 7 to memory
load(24,18);

load(11,5);
load(12,6); //load interrupt 1 to memory


load (13,7);
load (14,8);//load interrupt 2

load ( 15,9); //load interrupt 3
load ( 16,10);

load ( 17,11);
load ( 18,12); //load interrupt 4

load (9, 3);
load (10, 4);//load timer interrupt

[READY_LIST + 0] = 0; // Sets the entry for PID as 0 
load(25,21); // Load 1st page of code from disk to memory
load(26,22); // Load 2nd page of code from disk to memory
load(27,23); // Load 3rd page of code from disk to memory
PTBR=1024;
PTLR=4;
[PTBR + 0] = 25; // Physical Page Number for Logical Page 0
[PTBR + 1] = "01"; // Auxiliary Information for Logical Page 0
[PTBR + 2]= 26;
[PTBR+ 3]= "01";
[PTBR + 4]= 27;
[PTBR + 5]="01";
[PTBR + 6] = 28; // Physical Page Number for Logical Page 3 (Stack)
[PTBR + 7] = "01"; // Auxiliary Information for Logical Page 3 (Stack)
[READY_LIST + 1] = 2; // Sets the entry for STATE as Running 
SP = 3 * 512; //set stack pointer to 
 [28 * 512] = 0;//set IP value for init in stack---28 is the location of init's stack

load(5,19); //load FAT to memory

load(6,20);//load DISKFREELIST to memory

alias counter S0;			
counter = 0;
while ( counter <  128) do			// 64 entries, each of size 2 words
	[ FILE_TABLE + counter + 0] = -1;	// Set FAT Index to -1
	[ FILE_TABLE + counter + 1] =  0;	// Set File Open Count to 0
	counter = counter + 2;			// Move to next entry
endwhile;	

[READY_LIST + 15]=-1;
[READY_LIST + 16]=-1;
[READY_LIST + 17]=-1;
[READY_LIST + 18]=-1;
[READY_LIST + 19]=-1;
[READY_LIST + 20]=-1;
[READY_LIST + 21]=-1;
[READY_LIST + 22]=-1;
[READY_LIST + 23]=-1;
[READY_LIST + 24]=-1;
[READY_LIST + 25]=-1;
[READY_LIST + 26]=-1;
[READY_LIST + 27]=-1;
[READY_LIST + 28]=-1;
[READY_LIST + 29]=-1;
[READY_LIST + 30]=-1;				
ireturn;



