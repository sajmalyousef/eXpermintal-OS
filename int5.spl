alias physicalSP S0;
physicalSP = ([PTBR + 2 * (SP / 512)] * 512) + (SP % 512);
.
// Get system call no. from the stack and put it in a register
// Get arguments from stack and put it in registers
.

alias sysCallNo S1;
sysCallNo=[physicalSP-1];




alias freepcb S2;
freepcb = 0;
 

alias childPID S3;
print("start");

if(sysCallNo== 8) then
	//finds a free pcb
	while( freepcb < 512) do
	
	if([freepcb + READY_LIST + 1] ==0) then
		childPID = freepcb/32;
		[READY_LIST + freepcb] = childPID;
		break;
	endif;	
	freepcb = freepcb + 32;
	
	endwhile;
	
	if( freepcb == 512) then
		[physicalSP - 2] = -1;
		print("no pcb space");
		ireturn;
	endif;
	
	
	//search number of valid pages
	alias count S5;
	count=0;
		
	alias parentcount S6;
	parentcount=0;
	
	
	while(count < 4) do
		if([PTBR +count*2 + 1]=="11" || [PTBR + count*2 + 1]=="01") then
			parentcount = parentcount + 1;
		endif;
		count = count + 1;
	endwhile;
		
	alias  page S4;
	page=0;


	count=0;
	while ( page < 64) do
		if([MEM_LIST + page] == 0 ) then
			
			count= count + 1;
		 
		endif;
		if(count == parentcount) then
			break;
		endif;
		page = page + 1;
		
	endwhile;
	
	if(page== 64) then
		[physicalSP - 2]= -1;
		
		print("no memory");
		ireturn;
	endif;
	alias childPTBR S7;
	alias i S8;
	i=0;
	alias j S9;
	childPTBR = 1024 + childPID * 8;
	
	count = 0;
	while(count < 4) do

		//page is not valid no need to copy
		if([PTBR + count * 2 + 1]=="00" ) then
			[childPTBR + count * 2 + 1] ="00"; 
			
		
		else
			//valid page ..find a free page in memory
			i=0;
			while(i < 64) do
				if([MEM_LIST + i] == 0 ) then
					break;
				endif;
				i = i + 1;
			endwhile;
			

			 j= 0;
			//copying word by word
			while (j < 512) do
			
				[i * 512 + j] = [[PTBR + count * 2] * 512 + j];
				j = j + 1;
			endwhile;
			[childPTBR + count * 2] = i;
			[childPTBR + count * 2 + 1] = [PTBR + count * 2 + 1];
		
			[MEM_LIST + i] = 1;
			
		endif;

		
		count = count + 1;		
	endwhile;

	
	[READY_LIST + childPID * 32 + 4] = [physicalSP];
	[READY_LIST + childPID * 32 + 5] =childPTBR;
	[READY_LIST + childPID * 32 + 3] = SP - 1;
	[READY_LIST+childPID * 32 +2]=BP;
	[READY_LIST + childPID * 32 + 6] = 4; 
	[READY_LIST + childPID * 32 + 7] = R0;
	[READY_LIST + childPID * 32 + 8] = R1;
	[READY_LIST + childPID * 32 + 9] = R2;
	[READY_LIST + childPID * 32 + 10] = R3;
	[READY_LIST + childPID * 32 + 11] = R4;
	[READY_LIST + childPID * 32 + 12] = R5;
	[READY_LIST + childPID * 32 + 13] = R6;
	[READY_LIST + childPID * 32 + 14] = R7;
	[READY_LIST + childPID* 32 + 31] = (PTBR - 1024)/8;
	
	count = 0;
	alias childperprocess S8;
	alias perprocess S9;
	childperprocess = READY_LIST + childPID*32 + 15 ;
	perprocess   = READY_LIST + ((PTBR - 1024)/8) * 32 + 15;
	count =0;
	while (count < 8) do
		
		[childperprocess + count * 2] = [ perprocess + count * 2];	// pointer to SWOFT
		[childperprocess + count * 2 + 1] = [perprocess + count * 2 + 1];	// LSEEK position
		if([childperprocess + count * 2] != -1) then
			[FILE_TABLE + [perprocess + count* 2] * 2 + 1] = [FILE_TABLE + [perprocess + count* 2] * 2 + 1] + 1;
		endif;
	
		count = count + 1;
	endwhile;
	//child process is ready	
	[READY_LIST + childPID * 32  + 1] = 1;

// returnspace of parent has value of childPID
	[physicalSP - 2] = childPID;
	alias childphysicalSP S9;



	childphysicalSP = 	([childPTBR + 2 * ((SP-1) / 512)] * 512) + ((SP - 1) % 512);	
	[childphysicalSP - 1] = -2;
	print("complete");
	ireturn;
	

endif;
	
	
			
			

		

